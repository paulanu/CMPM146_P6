Partners:
	Paula Navarro Ulriksen
	Lex

Selection strategy:
	The first selection strategy I implemented was roulette selection. I generated a spin from 0 - total_fitness (fitness of all levels added up) and then went through each level, adding up the individual fitnesses, until the first level that goes over the spin is reached. That level is selected to be a parent. This works because levels with higher fitness will have a higher chance of being the level that reaches the spin threshhold. I repeated this process until a third of the population was selected to be successors
	The second selection strategy implement is tournament selection. In this one, 10 random "contestants" (or levels from the total population) are selected, and the one with the highest fitness level is chosen to be a successor. This process was repeated until, like the first strategy, a third of the population was selected to be successors. 
	The levels generated by the two successor strategies seem to be similar, except perhaps the ones created by the tournament selection were a bit more sparse. 
	Then, parents are randomly selected and crossovered from the successors until the population of the next generation equals the population of the first generation. At first this was implemented so that the same pair of parents will breed every time, but since I use a single point crossover (as explained below) that produced multiple of the same child.  

Crossover:
	At first crossover was implemented to be uniform, but the results produced were not cohesive, as in level became a random scattering of blocks. I changed it to single-point crossover, so half of the genes are from the left parent (or self) and the other half are from the right parent (or other). Only one child is produced per each pair of parents. 

Mutation: 
	Mutation is implemented through constraints. Each gene has a .003% chance of mutation. For each gene, there is a list of possible blocks to mutate to and a dictionary of weights for each block, so that some blocks have a higher chance of being picked for the mutation. The first constraint is that a gene that is not above any surface cannot mutate into a pipe or an enemy, since otherwise they would be floating in the level. However, genes that are floating in air can still be mutated into blocks that can be stood on, and furthermore have a higher chance of mutating into a standing block if the gene is already next to a block. In other words, this creates platforms. Finally, if the gene is at the bottom of the map, it can only mutate into an "X" or an "-", to create pits. 
	After the mutation is picked, more changes take place. If the gene is going to mutate into a pipe, a random height is selected and the pipe "grows" that height, and finally a pipe top "T" is placed at the top. This is to make sure all pipes are connected and "T"'s aren't randomly placed throughout. 
	In a similar vein, pits are created when a gene at the bottom of the level mutates into an empty space. A random width is selected and then all genes in that width are converted to empty spaces. 
	Finally, THIS IS WHERE YOU PUT IN THE JUMPING CONSTRAINT.   

Fitness function:

Initialization: 
	I changed the initialization of the first generation so that the majority (80%) of the levels would be empty levels. This fixed a problem of having crazy amounts of scattered blocks early on in the generations. 

Favorite level:
	It took ~30 generations and 2204 seconds for the favorite level to be generated. I like the variation in height and the number of obstacles to jump over. 

INDIVIDUAL ENCODING:

mutation:
	
Crossover:

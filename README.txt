Partners:
	Paula Navarro Ulriksen
	Alexai Zachow

Selection strategy:
	The first selection strategy I implemented was roulette selection. I generated a spin from 0 - total_fitness (fitness of all levels added up) and then went through each level, adding up the individual fitnesses, until the first level that goes over the spin is reached. That level is selected to be a parent. This works because levels with higher fitness will have a higher chance of being the level that reaches the spin threshhold. I repeated this process until a third of the population was selected to be successors
	The second selection strategy implement is tournament selection. In this one, 10 random "contestants" (or levels from the total population) are selected, and the one with the highest fitness level is chosen to be a successor. This process was repeated until, like the first strategy, a third of the population was selected to be successors. 
	The levels generated by the two successor strategies seem to be similar, except perhaps the ones created by the tournament selection were a bit more sparse. 
	Then, parents are randomly selected and crossovered from the successors until the population of the next generation equals the population of the first generation. At first this was implemented so that the same pair of parents will breed every time, but since I use a single point crossover (as explained below) that produced multiple of the same child.  

Crossover:
	At first crossover was implemented to be uniform, but the results produced were not cohesive, as in level became a random scattering of blocks. I changed it to single-point crossover, so half of the genes are from the left parent (or self) and the other half are from the right parent (or other). Only one child is produced per each pair of parents. 

Mutation: 
	Mutation is implemented through constraints. Each gene has a .003% chance of mutation. For each gene, there is a list of possible blocks to mutate to and a dictionary of weights for each block, so that some blocks have a higher chance of being picked for the mutation. The first constraint is that a gene that is not above any surface cannot mutate into a pipe or an enemy, since otherwise they would be floating in the level. However, genes that are floating in air can still be mutated into blocks that can be stood on, and furthermore have a higher chance of mutating into a standing block if the gene is already next to a block. In other words, this creates platforms. Finally, if the gene is at the bottom of the map, it can only mutate into an "X" or an "-", to create pits. 
	After the mutation is picked, more changes take place. If the gene is going to mutate into a pipe, a random height is selected and the pipe "grows" that height, and finally a pipe top "T" is placed at the top. This is to make sure all pipes are connected and "T"'s aren't randomly placed throughout. 
	In a similar vein, pits are created when a gene at the bottom of the level mutates into an empty space. A random width is selected and then all genes in that width are converted to empty spaces. 
	Finally, we decided to add a constraint to make sure that all blocks and coins we place are reachable. Essentially, this function looks at each block and sees if there's a jumpable block within 4 tiles of the block's sides or bottom. If not, it sets that block to an empty
	tile, since Mario can only jump 5 blocks.

Fitness function:
	The fitness function works to make levels that are both populated and navigable. The function prioritizes solvability over all else, as an unsolvable level is pretty worthless. Next, the function tries to make levels that have many branching paths,
	but where each of those paths have meaningful jumps. This was done with the intention to creat a "choose your own adventure" style of level, but it created levels that had "tiers" where a skilled player could jump from block to block in order to
	avoid contact with the hazards on the ground. The most insignificant of the metrics we selected for were related to the percentage of negative space and the amount of empty space that was pathable. This was analyzed in an attempt to give the levels
	a noticable amount of verticality. Having a large amount of pathable empty space should imply that a large amount of the space in the air on top of blocks is pathable, since the ground is a given in terms of pathability.

Initialization: 
	I changed the initialization of the first generation so that the majority (80%) of the levels would be empty levels. This fixed a problem of having crazy amounts of scattered blocks early on in the generations. 

Favorite level:
	It took ~30 generations and 2204 seconds for the favorite level to be generated. I like the variation in height and the number of obstacles to jump over.
	
Competition:
	We intend to participate in the competition.

INDIVIDUAL ENCODING:

Mutation:
	The mutation algorithm generates a random number and, depending on the type of tile being mutated, offsets the tile's gene by a bounded amount using bounds dependent on the random number generated, turning it into another tile.
Crossover:
	The algorithm picks a random set of genes from one parent. It then takes the opposite set of genes from other parent and completes the genome. The leftover genes are combined into a second, "opposite," genome, both of which are returned.